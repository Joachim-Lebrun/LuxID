/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import {
  ethers,
  EventFilter,
  Signer,
  BigNumber,
  BigNumberish,
  PopulatedTransaction,
  BaseContract,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  CallOverrides,
} from "ethers";
import { BytesLike } from "@ethersproject/bytes";
import { Listener, Provider } from "@ethersproject/providers";
import { FunctionFragment, EventFragment, Result } from "@ethersproject/abi";
import type { TypedEventFilter, TypedEvent, TypedListener } from "./common";

interface ClaimIssuerInterface extends ethers.utils.Interface {
  functions: {
    "addClaim(uint256,uint256,address,bytes,bytes,string)": FunctionFragment;
    "addKey(bytes32,uint256,uint256)": FunctionFragment;
    "approve(uint256,bool)": FunctionFragment;
    "execute(address,uint256,bytes)": FunctionFragment;
    "getClaim(bytes32)": FunctionFragment;
    "getClaimIdsByTopic(uint256)": FunctionFragment;
    "getKey(bytes32)": FunctionFragment;
    "getKeyPurposes(bytes32)": FunctionFragment;
    "getKeysByPurpose(uint256)": FunctionFragment;
    "initialize(address,address)": FunctionFragment;
    "keyHasPurpose(bytes32,uint256)": FunctionFragment;
    "removeClaim(bytes32)": FunctionFragment;
    "removeKey(bytes32,uint256)": FunctionFragment;
    "revokedClaims(bytes)": FunctionFragment;
    "version()": FunctionFragment;
    "revokeClaim(bytes32,address)": FunctionFragment;
    "isClaimRevoked(bytes)": FunctionFragment;
    "isClaimValid(address,uint256,bytes,bytes)": FunctionFragment;
    "getRecoveredAddress(bytes,bytes32)": FunctionFragment;
  };

  encodeFunctionData(
    functionFragment: "addClaim",
    values: [BigNumberish, BigNumberish, string, BytesLike, BytesLike, string]
  ): string;
  encodeFunctionData(
    functionFragment: "addKey",
    values: [BytesLike, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "approve",
    values: [BigNumberish, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "execute",
    values: [string, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(functionFragment: "getClaim", values: [BytesLike]): string;
  encodeFunctionData(
    functionFragment: "getClaimIdsByTopic",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "getKey", values: [BytesLike]): string;
  encodeFunctionData(
    functionFragment: "getKeyPurposes",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getKeysByPurpose",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "initialize",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "keyHasPurpose",
    values: [BytesLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "removeClaim",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "removeKey",
    values: [BytesLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "revokedClaims",
    values: [BytesLike]
  ): string;
  encodeFunctionData(functionFragment: "version", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "revokeClaim",
    values: [BytesLike, string]
  ): string;
  encodeFunctionData(
    functionFragment: "isClaimRevoked",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "isClaimValid",
    values: [string, BigNumberish, BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getRecoveredAddress",
    values: [BytesLike, BytesLike]
  ): string;

  decodeFunctionResult(functionFragment: "addClaim", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "addKey", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "approve", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "execute", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "getClaim", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getClaimIdsByTopic",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getKey", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getKeyPurposes",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getKeysByPurpose",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "initialize", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "keyHasPurpose",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "removeClaim",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "removeKey", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "revokedClaims",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "version", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "revokeClaim",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isClaimRevoked",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isClaimValid",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getRecoveredAddress",
    data: BytesLike
  ): Result;

  events: {
    "Approved(uint256,bool)": EventFragment;
    "ClaimAdded(bytes32,uint256,uint256,address,bytes,bytes,string)": EventFragment;
    "ClaimChanged(bytes32,uint256,uint256,address,bytes,bytes,string)": EventFragment;
    "ClaimRemoved(bytes32,uint256,uint256,address,bytes,bytes,string)": EventFragment;
    "ClaimRequested(uint256,uint256,uint256,address,bytes,bytes,string)": EventFragment;
    "Executed(uint256,address,uint256,bytes)": EventFragment;
    "ExecutionFailed(uint256,address,uint256,bytes)": EventFragment;
    "ExecutionRequested(uint256,address,uint256,bytes)": EventFragment;
    "KeyAdded(bytes32,uint256,uint256)": EventFragment;
    "KeyRemoved(bytes32,uint256,uint256)": EventFragment;
    "KeysRequiredChanged(uint256,uint256)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "Approved"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ClaimAdded"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ClaimChanged"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ClaimRemoved"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ClaimRequested"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Executed"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ExecutionFailed"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ExecutionRequested"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "KeyAdded"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "KeyRemoved"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "KeysRequiredChanged"): EventFragment;
}

export type ApprovedEvent = TypedEvent<
  [BigNumber, boolean] & { executionId: BigNumber; approved: boolean }
>;

export type ClaimAddedEvent = TypedEvent<
  [string, BigNumber, BigNumber, string, string, string, string] & {
    claimId: string;
    topic: BigNumber;
    scheme: BigNumber;
    issuer: string;
    signature: string;
    data: string;
    uri: string;
  }
>;

export type ClaimChangedEvent = TypedEvent<
  [string, BigNumber, BigNumber, string, string, string, string] & {
    claimId: string;
    topic: BigNumber;
    scheme: BigNumber;
    issuer: string;
    signature: string;
    data: string;
    uri: string;
  }
>;

export type ClaimRemovedEvent = TypedEvent<
  [string, BigNumber, BigNumber, string, string, string, string] & {
    claimId: string;
    topic: BigNumber;
    scheme: BigNumber;
    issuer: string;
    signature: string;
    data: string;
    uri: string;
  }
>;

export type ClaimRequestedEvent = TypedEvent<
  [BigNumber, BigNumber, BigNumber, string, string, string, string] & {
    claimRequestId: BigNumber;
    topic: BigNumber;
    scheme: BigNumber;
    issuer: string;
    signature: string;
    data: string;
    uri: string;
  }
>;

export type ExecutedEvent = TypedEvent<
  [BigNumber, string, BigNumber, string] & {
    executionId: BigNumber;
    to: string;
    value: BigNumber;
    data: string;
  }
>;

export type ExecutionFailedEvent = TypedEvent<
  [BigNumber, string, BigNumber, string] & {
    executionId: BigNumber;
    to: string;
    value: BigNumber;
    data: string;
  }
>;

export type ExecutionRequestedEvent = TypedEvent<
  [BigNumber, string, BigNumber, string] & {
    executionId: BigNumber;
    to: string;
    value: BigNumber;
    data: string;
  }
>;

export type KeyAddedEvent = TypedEvent<
  [string, BigNumber, BigNumber] & {
    key: string;
    purpose: BigNumber;
    keyType: BigNumber;
  }
>;

export type KeyRemovedEvent = TypedEvent<
  [string, BigNumber, BigNumber] & {
    key: string;
    purpose: BigNumber;
    keyType: BigNumber;
  }
>;

export type KeysRequiredChangedEvent = TypedEvent<
  [BigNumber, BigNumber] & { purpose: BigNumber; number: BigNumber }
>;

export class ClaimIssuer extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  listeners<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter?: TypedEventFilter<EventArgsArray, EventArgsObject>
  ): Array<TypedListener<EventArgsArray, EventArgsObject>>;
  off<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  on<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  once<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  removeListener<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  removeAllListeners<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>
  ): this;

  listeners(eventName?: string): Array<Listener>;
  off(eventName: string, listener: Listener): this;
  on(eventName: string, listener: Listener): this;
  once(eventName: string, listener: Listener): this;
  removeListener(eventName: string, listener: Listener): this;
  removeAllListeners(eventName?: string): this;

  queryFilter<EventArgsArray extends Array<any>, EventArgsObject>(
    event: TypedEventFilter<EventArgsArray, EventArgsObject>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEvent<EventArgsArray & EventArgsObject>>>;

  interface: ClaimIssuerInterface;

  functions: {
    /**
     * Implementation of the addClaim function from the ERC-735 standard  Require that the msg.sender has claim signer key.
     * @param _data The hash of the claim data, sitting in another location, a bit-mask, call data, or actual data based on the claim scheme.
     * @param _issuer The issuers identity contract address, or the address used to sign the above signature.
     * @param _scheme The scheme with which this claim SHOULD be verified or how it should be processed.
     * @param _signature Signature which is the proof that the claim issuer issued a claim of topic for this identity. it MUST be a signed message of the following structure: keccak256(abi.encode(address identityHolder_address, uint256 _ topic, bytes data))
     * @param _topic The type of claim
     * @param _uri The location of the claim, this can be HTTP links, swarm hashes, IPFS hashes, and such.
     */
    addClaim(
      _topic: BigNumberish,
      _scheme: BigNumberish,
      _issuer: string,
      _signature: BytesLike,
      _data: BytesLike,
      _uri: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * implementation of the addKey function of the ERC-734 standard Adds a _key to the identity. The _purpose specifies the purpose of key. Initially we propose four purposes: 1: MANAGEMENT keys, which can manage the identity 2: ACTION keys, which perform actions in this identities name (signing, logins, transactions, etc.) 3: CLAIM signer keys, used to sign claims on other identities which need to be revokable. 4: ENCRYPTION keys, used to encrypt data e.g. hold in claims. MUST only be done by keys of purpose 1, or the identity itself. If its the identity itself, the approval process will determine its approval.
     * @param _key keccak256 representation of an ethereum address
     * @param _purpose a uint256[] Array of the key types, like 1 = MANAGEMENT, 2 = ACTION, 3 = CLAIM, 4 = ENCRYPTION
     * @param _type type of key used, which would be a uint256 for different key types. e.g. 1 = ECDSA, 2 = RSA, etc.
     */
    addKey(
      _key: BytesLike,
      _purpose: BigNumberish,
      _type: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Approves an execution or claim addition. This SHOULD require n of m approvals of keys purpose 1, if the _to of the execution is the identity contract itself, to successfully approve an execution. And COULD require n of m approvals of keys purpose 2, if the _to of the execution is another contract, to successfully approve an execution.
     */
    approve(
      _id: BigNumberish,
      _approve: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Passes an execution instruction to the keymanager. SHOULD require approve to be called with one or more keys of purpose 1 or 2 to approve this execution. Execute COULD be used as the only accessor for addKey, removeKey and replaceKey and removeClaim.
     */
    execute(
      _to: string,
      _value: BigNumberish,
      _data: BytesLike,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Implementation of the getClaim function from the ERC-735 standard.
     * @param _claimId The identity of the claim i.e. keccak256(abi.encode(_issuer, _topic))
     */
    getClaim(
      _claimId: BytesLike,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, string, string, string, string] & {
        topic: BigNumber;
        scheme: BigNumber;
        issuer: string;
        signature: string;
        data: string;
        uri: string;
      }
    >;

    /**
     * Implementation of the getClaimIdsByTopic function from the ERC-735 standard. used to get all the claims from the specified topic
     * @param _topic The identity of the claim i.e. keccak256(abi.encode(_issuer, _topic))
     */
    getClaimIdsByTopic(
      _topic: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[string[]] & { claimIds: string[] }>;

    /**
     * Implementation of the getKey function from the ERC-734 standard
     * @param _key The public key.  for non-hex and long keys, its the Keccak256 hash of the key
     */
    getKey(
      _key: BytesLike,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber[], BigNumber, string] & {
        purposes: BigNumber[];
        keyType: BigNumber;
        key: string;
      }
    >;

    /**
     * gets the purposes of a key
     * @param _key The public key.  for non-hex and long keys, its the Keccak256 hash of the key
     */
    getKeyPurposes(
      _key: BytesLike,
      overrides?: CallOverrides
    ): Promise<[BigNumber[]] & { _purposes: BigNumber[] }>;

    /**
     * gets all the keys with a specific purpose from an identity
     * @param _purpose a uint256[] Array of the key types, like 1 = MANAGEMENT, 2 = ACTION, 3 = CLAIM, 4 = ENCRYPTION
     */
    getKeysByPurpose(
      _purpose: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[string[]] & { _keys: string[] }>;

    /**
     * When using this contract as an implementation for a proxy, call this initializer with a delegatecall.
     * @param initialManagementKey The ethereum address to be set as the management key of the ONCHAINID.
     */
    initialize(
      initialManagementKey: string,
      _luxAdmin: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Returns true if the key has MANAGEMENT purpose or the specified purpose.
     */
    keyHasPurpose(
      _key: BytesLike,
      _purpose: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[boolean] & { result: boolean }>;

    /**
     * Implementation of the removeClaim function from the ERC-735 standard Require that the msg.sender has management key. Can only be removed by the claim issuer, or the claim holder itself.
     * @param _claimId The identity of the claim i.e. keccak256(abi.encode(_issuer, _topic))
     */
    removeClaim(
      _claimId: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Remove the purpose from a key.
     */
    removeKey(
      _key: BytesLike,
      _purpose: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    revokedClaims(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    /**
     * Returns the string of the current version.
     */
    version(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Revoke a claim previously issued, the claim is no longer considered as valid after revocation.
     * @param _claimId the id of the claim
     * @param _identity the address of the identity contract
     */
    revokeClaim(
      _claimId: BytesLike,
      _identity: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Returns revocation status of a claim.
     * @param _sig the signature of the claim
     */
    isClaimRevoked(
      _sig: BytesLike,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    /**
     * Checks if a claim is valid.
     * @param _identity the identity contract related to the claim
     * @param claimTopic the claim topic of the claim
     * @param data the data field of the claim
     * @param sig the signature of the claim
     */
    isClaimValid(
      _identity: string,
      claimTopic: BigNumberish,
      sig: BytesLike,
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<[boolean] & { claimValid: boolean }>;

    getRecoveredAddress(
      sig: BytesLike,
      dataHash: BytesLike,
      overrides?: CallOverrides
    ): Promise<[string] & { addr: string }>;
  };

  /**
   * Implementation of the addClaim function from the ERC-735 standard  Require that the msg.sender has claim signer key.
   * @param _data The hash of the claim data, sitting in another location, a bit-mask, call data, or actual data based on the claim scheme.
   * @param _issuer The issuers identity contract address, or the address used to sign the above signature.
   * @param _scheme The scheme with which this claim SHOULD be verified or how it should be processed.
   * @param _signature Signature which is the proof that the claim issuer issued a claim of topic for this identity. it MUST be a signed message of the following structure: keccak256(abi.encode(address identityHolder_address, uint256 _ topic, bytes data))
   * @param _topic The type of claim
   * @param _uri The location of the claim, this can be HTTP links, swarm hashes, IPFS hashes, and such.
   */
  addClaim(
    _topic: BigNumberish,
    _scheme: BigNumberish,
    _issuer: string,
    _signature: BytesLike,
    _data: BytesLike,
    _uri: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * implementation of the addKey function of the ERC-734 standard Adds a _key to the identity. The _purpose specifies the purpose of key. Initially we propose four purposes: 1: MANAGEMENT keys, which can manage the identity 2: ACTION keys, which perform actions in this identities name (signing, logins, transactions, etc.) 3: CLAIM signer keys, used to sign claims on other identities which need to be revokable. 4: ENCRYPTION keys, used to encrypt data e.g. hold in claims. MUST only be done by keys of purpose 1, or the identity itself. If its the identity itself, the approval process will determine its approval.
   * @param _key keccak256 representation of an ethereum address
   * @param _purpose a uint256[] Array of the key types, like 1 = MANAGEMENT, 2 = ACTION, 3 = CLAIM, 4 = ENCRYPTION
   * @param _type type of key used, which would be a uint256 for different key types. e.g. 1 = ECDSA, 2 = RSA, etc.
   */
  addKey(
    _key: BytesLike,
    _purpose: BigNumberish,
    _type: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Approves an execution or claim addition. This SHOULD require n of m approvals of keys purpose 1, if the _to of the execution is the identity contract itself, to successfully approve an execution. And COULD require n of m approvals of keys purpose 2, if the _to of the execution is another contract, to successfully approve an execution.
   */
  approve(
    _id: BigNumberish,
    _approve: boolean,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Passes an execution instruction to the keymanager. SHOULD require approve to be called with one or more keys of purpose 1 or 2 to approve this execution. Execute COULD be used as the only accessor for addKey, removeKey and replaceKey and removeClaim.
   */
  execute(
    _to: string,
    _value: BigNumberish,
    _data: BytesLike,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Implementation of the getClaim function from the ERC-735 standard.
   * @param _claimId The identity of the claim i.e. keccak256(abi.encode(_issuer, _topic))
   */
  getClaim(
    _claimId: BytesLike,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber, string, string, string, string] & {
      topic: BigNumber;
      scheme: BigNumber;
      issuer: string;
      signature: string;
      data: string;
      uri: string;
    }
  >;

  /**
   * Implementation of the getClaimIdsByTopic function from the ERC-735 standard. used to get all the claims from the specified topic
   * @param _topic The identity of the claim i.e. keccak256(abi.encode(_issuer, _topic))
   */
  getClaimIdsByTopic(
    _topic: BigNumberish,
    overrides?: CallOverrides
  ): Promise<string[]>;

  /**
   * Implementation of the getKey function from the ERC-734 standard
   * @param _key The public key.  for non-hex and long keys, its the Keccak256 hash of the key
   */
  getKey(
    _key: BytesLike,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber[], BigNumber, string] & {
      purposes: BigNumber[];
      keyType: BigNumber;
      key: string;
    }
  >;

  /**
   * gets the purposes of a key
   * @param _key The public key.  for non-hex and long keys, its the Keccak256 hash of the key
   */
  getKeyPurposes(
    _key: BytesLike,
    overrides?: CallOverrides
  ): Promise<BigNumber[]>;

  /**
   * gets all the keys with a specific purpose from an identity
   * @param _purpose a uint256[] Array of the key types, like 1 = MANAGEMENT, 2 = ACTION, 3 = CLAIM, 4 = ENCRYPTION
   */
  getKeysByPurpose(
    _purpose: BigNumberish,
    overrides?: CallOverrides
  ): Promise<string[]>;

  /**
   * When using this contract as an implementation for a proxy, call this initializer with a delegatecall.
   * @param initialManagementKey The ethereum address to be set as the management key of the ONCHAINID.
   */
  initialize(
    initialManagementKey: string,
    _luxAdmin: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Returns true if the key has MANAGEMENT purpose or the specified purpose.
   */
  keyHasPurpose(
    _key: BytesLike,
    _purpose: BigNumberish,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * Implementation of the removeClaim function from the ERC-735 standard Require that the msg.sender has management key. Can only be removed by the claim issuer, or the claim holder itself.
   * @param _claimId The identity of the claim i.e. keccak256(abi.encode(_issuer, _topic))
   */
  removeClaim(
    _claimId: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Remove the purpose from a key.
   */
  removeKey(
    _key: BytesLike,
    _purpose: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  revokedClaims(arg0: BytesLike, overrides?: CallOverrides): Promise<boolean>;

  /**
   * Returns the string of the current version.
   */
  version(overrides?: CallOverrides): Promise<string>;

  /**
   * Revoke a claim previously issued, the claim is no longer considered as valid after revocation.
   * @param _claimId the id of the claim
   * @param _identity the address of the identity contract
   */
  revokeClaim(
    _claimId: BytesLike,
    _identity: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Returns revocation status of a claim.
   * @param _sig the signature of the claim
   */
  isClaimRevoked(_sig: BytesLike, overrides?: CallOverrides): Promise<boolean>;

  /**
   * Checks if a claim is valid.
   * @param _identity the identity contract related to the claim
   * @param claimTopic the claim topic of the claim
   * @param data the data field of the claim
   * @param sig the signature of the claim
   */
  isClaimValid(
    _identity: string,
    claimTopic: BigNumberish,
    sig: BytesLike,
    data: BytesLike,
    overrides?: CallOverrides
  ): Promise<boolean>;

  getRecoveredAddress(
    sig: BytesLike,
    dataHash: BytesLike,
    overrides?: CallOverrides
  ): Promise<string>;

  callStatic: {
    /**
     * Implementation of the addClaim function from the ERC-735 standard  Require that the msg.sender has claim signer key.
     * @param _data The hash of the claim data, sitting in another location, a bit-mask, call data, or actual data based on the claim scheme.
     * @param _issuer The issuers identity contract address, or the address used to sign the above signature.
     * @param _scheme The scheme with which this claim SHOULD be verified or how it should be processed.
     * @param _signature Signature which is the proof that the claim issuer issued a claim of topic for this identity. it MUST be a signed message of the following structure: keccak256(abi.encode(address identityHolder_address, uint256 _ topic, bytes data))
     * @param _topic The type of claim
     * @param _uri The location of the claim, this can be HTTP links, swarm hashes, IPFS hashes, and such.
     */
    addClaim(
      _topic: BigNumberish,
      _scheme: BigNumberish,
      _issuer: string,
      _signature: BytesLike,
      _data: BytesLike,
      _uri: string,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * implementation of the addKey function of the ERC-734 standard Adds a _key to the identity. The _purpose specifies the purpose of key. Initially we propose four purposes: 1: MANAGEMENT keys, which can manage the identity 2: ACTION keys, which perform actions in this identities name (signing, logins, transactions, etc.) 3: CLAIM signer keys, used to sign claims on other identities which need to be revokable. 4: ENCRYPTION keys, used to encrypt data e.g. hold in claims. MUST only be done by keys of purpose 1, or the identity itself. If its the identity itself, the approval process will determine its approval.
     * @param _key keccak256 representation of an ethereum address
     * @param _purpose a uint256[] Array of the key types, like 1 = MANAGEMENT, 2 = ACTION, 3 = CLAIM, 4 = ENCRYPTION
     * @param _type type of key used, which would be a uint256 for different key types. e.g. 1 = ECDSA, 2 = RSA, etc.
     */
    addKey(
      _key: BytesLike,
      _purpose: BigNumberish,
      _type: BigNumberish,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Approves an execution or claim addition. This SHOULD require n of m approvals of keys purpose 1, if the _to of the execution is the identity contract itself, to successfully approve an execution. And COULD require n of m approvals of keys purpose 2, if the _to of the execution is another contract, to successfully approve an execution.
     */
    approve(
      _id: BigNumberish,
      _approve: boolean,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Passes an execution instruction to the keymanager. SHOULD require approve to be called with one or more keys of purpose 1 or 2 to approve this execution. Execute COULD be used as the only accessor for addKey, removeKey and replaceKey and removeClaim.
     */
    execute(
      _to: string,
      _value: BigNumberish,
      _data: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Implementation of the getClaim function from the ERC-735 standard.
     * @param _claimId The identity of the claim i.e. keccak256(abi.encode(_issuer, _topic))
     */
    getClaim(
      _claimId: BytesLike,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, string, string, string, string] & {
        topic: BigNumber;
        scheme: BigNumber;
        issuer: string;
        signature: string;
        data: string;
        uri: string;
      }
    >;

    /**
     * Implementation of the getClaimIdsByTopic function from the ERC-735 standard. used to get all the claims from the specified topic
     * @param _topic The identity of the claim i.e. keccak256(abi.encode(_issuer, _topic))
     */
    getClaimIdsByTopic(
      _topic: BigNumberish,
      overrides?: CallOverrides
    ): Promise<string[]>;

    /**
     * Implementation of the getKey function from the ERC-734 standard
     * @param _key The public key.  for non-hex and long keys, its the Keccak256 hash of the key
     */
    getKey(
      _key: BytesLike,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber[], BigNumber, string] & {
        purposes: BigNumber[];
        keyType: BigNumber;
        key: string;
      }
    >;

    /**
     * gets the purposes of a key
     * @param _key The public key.  for non-hex and long keys, its the Keccak256 hash of the key
     */
    getKeyPurposes(
      _key: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber[]>;

    /**
     * gets all the keys with a specific purpose from an identity
     * @param _purpose a uint256[] Array of the key types, like 1 = MANAGEMENT, 2 = ACTION, 3 = CLAIM, 4 = ENCRYPTION
     */
    getKeysByPurpose(
      _purpose: BigNumberish,
      overrides?: CallOverrides
    ): Promise<string[]>;

    /**
     * When using this contract as an implementation for a proxy, call this initializer with a delegatecall.
     * @param initialManagementKey The ethereum address to be set as the management key of the ONCHAINID.
     */
    initialize(
      initialManagementKey: string,
      _luxAdmin: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Returns true if the key has MANAGEMENT purpose or the specified purpose.
     */
    keyHasPurpose(
      _key: BytesLike,
      _purpose: BigNumberish,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Implementation of the removeClaim function from the ERC-735 standard Require that the msg.sender has management key. Can only be removed by the claim issuer, or the claim holder itself.
     * @param _claimId The identity of the claim i.e. keccak256(abi.encode(_issuer, _topic))
     */
    removeClaim(
      _claimId: BytesLike,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Remove the purpose from a key.
     */
    removeKey(
      _key: BytesLike,
      _purpose: BigNumberish,
      overrides?: CallOverrides
    ): Promise<boolean>;

    revokedClaims(arg0: BytesLike, overrides?: CallOverrides): Promise<boolean>;

    /**
     * Returns the string of the current version.
     */
    version(overrides?: CallOverrides): Promise<string>;

    /**
     * Revoke a claim previously issued, the claim is no longer considered as valid after revocation.
     * @param _claimId the id of the claim
     * @param _identity the address of the identity contract
     */
    revokeClaim(
      _claimId: BytesLike,
      _identity: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Returns revocation status of a claim.
     * @param _sig the signature of the claim
     */
    isClaimRevoked(
      _sig: BytesLike,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Checks if a claim is valid.
     * @param _identity the identity contract related to the claim
     * @param claimTopic the claim topic of the claim
     * @param data the data field of the claim
     * @param sig the signature of the claim
     */
    isClaimValid(
      _identity: string,
      claimTopic: BigNumberish,
      sig: BytesLike,
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<boolean>;

    getRecoveredAddress(
      sig: BytesLike,
      dataHash: BytesLike,
      overrides?: CallOverrides
    ): Promise<string>;
  };

  filters: {
    "Approved(uint256,bool)"(
      executionId?: BigNumberish | null,
      approved?: null
    ): TypedEventFilter<
      [BigNumber, boolean],
      { executionId: BigNumber; approved: boolean }
    >;

    Approved(
      executionId?: BigNumberish | null,
      approved?: null
    ): TypedEventFilter<
      [BigNumber, boolean],
      { executionId: BigNumber; approved: boolean }
    >;

    "ClaimAdded(bytes32,uint256,uint256,address,bytes,bytes,string)"(
      claimId?: BytesLike | null,
      topic?: BigNumberish | null,
      scheme?: null,
      issuer?: string | null,
      signature?: null,
      data?: null,
      uri?: null
    ): TypedEventFilter<
      [string, BigNumber, BigNumber, string, string, string, string],
      {
        claimId: string;
        topic: BigNumber;
        scheme: BigNumber;
        issuer: string;
        signature: string;
        data: string;
        uri: string;
      }
    >;

    ClaimAdded(
      claimId?: BytesLike | null,
      topic?: BigNumberish | null,
      scheme?: null,
      issuer?: string | null,
      signature?: null,
      data?: null,
      uri?: null
    ): TypedEventFilter<
      [string, BigNumber, BigNumber, string, string, string, string],
      {
        claimId: string;
        topic: BigNumber;
        scheme: BigNumber;
        issuer: string;
        signature: string;
        data: string;
        uri: string;
      }
    >;

    "ClaimChanged(bytes32,uint256,uint256,address,bytes,bytes,string)"(
      claimId?: BytesLike | null,
      topic?: BigNumberish | null,
      scheme?: null,
      issuer?: string | null,
      signature?: null,
      data?: null,
      uri?: null
    ): TypedEventFilter<
      [string, BigNumber, BigNumber, string, string, string, string],
      {
        claimId: string;
        topic: BigNumber;
        scheme: BigNumber;
        issuer: string;
        signature: string;
        data: string;
        uri: string;
      }
    >;

    ClaimChanged(
      claimId?: BytesLike | null,
      topic?: BigNumberish | null,
      scheme?: null,
      issuer?: string | null,
      signature?: null,
      data?: null,
      uri?: null
    ): TypedEventFilter<
      [string, BigNumber, BigNumber, string, string, string, string],
      {
        claimId: string;
        topic: BigNumber;
        scheme: BigNumber;
        issuer: string;
        signature: string;
        data: string;
        uri: string;
      }
    >;

    "ClaimRemoved(bytes32,uint256,uint256,address,bytes,bytes,string)"(
      claimId?: BytesLike | null,
      topic?: BigNumberish | null,
      scheme?: null,
      issuer?: string | null,
      signature?: null,
      data?: null,
      uri?: null
    ): TypedEventFilter<
      [string, BigNumber, BigNumber, string, string, string, string],
      {
        claimId: string;
        topic: BigNumber;
        scheme: BigNumber;
        issuer: string;
        signature: string;
        data: string;
        uri: string;
      }
    >;

    ClaimRemoved(
      claimId?: BytesLike | null,
      topic?: BigNumberish | null,
      scheme?: null,
      issuer?: string | null,
      signature?: null,
      data?: null,
      uri?: null
    ): TypedEventFilter<
      [string, BigNumber, BigNumber, string, string, string, string],
      {
        claimId: string;
        topic: BigNumber;
        scheme: BigNumber;
        issuer: string;
        signature: string;
        data: string;
        uri: string;
      }
    >;

    "ClaimRequested(uint256,uint256,uint256,address,bytes,bytes,string)"(
      claimRequestId?: BigNumberish | null,
      topic?: BigNumberish | null,
      scheme?: null,
      issuer?: string | null,
      signature?: null,
      data?: null,
      uri?: null
    ): TypedEventFilter<
      [BigNumber, BigNumber, BigNumber, string, string, string, string],
      {
        claimRequestId: BigNumber;
        topic: BigNumber;
        scheme: BigNumber;
        issuer: string;
        signature: string;
        data: string;
        uri: string;
      }
    >;

    ClaimRequested(
      claimRequestId?: BigNumberish | null,
      topic?: BigNumberish | null,
      scheme?: null,
      issuer?: string | null,
      signature?: null,
      data?: null,
      uri?: null
    ): TypedEventFilter<
      [BigNumber, BigNumber, BigNumber, string, string, string, string],
      {
        claimRequestId: BigNumber;
        topic: BigNumber;
        scheme: BigNumber;
        issuer: string;
        signature: string;
        data: string;
        uri: string;
      }
    >;

    "Executed(uint256,address,uint256,bytes)"(
      executionId?: BigNumberish | null,
      to?: string | null,
      value?: BigNumberish | null,
      data?: null
    ): TypedEventFilter<
      [BigNumber, string, BigNumber, string],
      { executionId: BigNumber; to: string; value: BigNumber; data: string }
    >;

    Executed(
      executionId?: BigNumberish | null,
      to?: string | null,
      value?: BigNumberish | null,
      data?: null
    ): TypedEventFilter<
      [BigNumber, string, BigNumber, string],
      { executionId: BigNumber; to: string; value: BigNumber; data: string }
    >;

    "ExecutionFailed(uint256,address,uint256,bytes)"(
      executionId?: BigNumberish | null,
      to?: string | null,
      value?: BigNumberish | null,
      data?: null
    ): TypedEventFilter<
      [BigNumber, string, BigNumber, string],
      { executionId: BigNumber; to: string; value: BigNumber; data: string }
    >;

    ExecutionFailed(
      executionId?: BigNumberish | null,
      to?: string | null,
      value?: BigNumberish | null,
      data?: null
    ): TypedEventFilter<
      [BigNumber, string, BigNumber, string],
      { executionId: BigNumber; to: string; value: BigNumber; data: string }
    >;

    "ExecutionRequested(uint256,address,uint256,bytes)"(
      executionId?: BigNumberish | null,
      to?: string | null,
      value?: BigNumberish | null,
      data?: null
    ): TypedEventFilter<
      [BigNumber, string, BigNumber, string],
      { executionId: BigNumber; to: string; value: BigNumber; data: string }
    >;

    ExecutionRequested(
      executionId?: BigNumberish | null,
      to?: string | null,
      value?: BigNumberish | null,
      data?: null
    ): TypedEventFilter<
      [BigNumber, string, BigNumber, string],
      { executionId: BigNumber; to: string; value: BigNumber; data: string }
    >;

    "KeyAdded(bytes32,uint256,uint256)"(
      key?: BytesLike | null,
      purpose?: BigNumberish | null,
      keyType?: BigNumberish | null
    ): TypedEventFilter<
      [string, BigNumber, BigNumber],
      { key: string; purpose: BigNumber; keyType: BigNumber }
    >;

    KeyAdded(
      key?: BytesLike | null,
      purpose?: BigNumberish | null,
      keyType?: BigNumberish | null
    ): TypedEventFilter<
      [string, BigNumber, BigNumber],
      { key: string; purpose: BigNumber; keyType: BigNumber }
    >;

    "KeyRemoved(bytes32,uint256,uint256)"(
      key?: BytesLike | null,
      purpose?: BigNumberish | null,
      keyType?: BigNumberish | null
    ): TypedEventFilter<
      [string, BigNumber, BigNumber],
      { key: string; purpose: BigNumber; keyType: BigNumber }
    >;

    KeyRemoved(
      key?: BytesLike | null,
      purpose?: BigNumberish | null,
      keyType?: BigNumberish | null
    ): TypedEventFilter<
      [string, BigNumber, BigNumber],
      { key: string; purpose: BigNumber; keyType: BigNumber }
    >;

    "KeysRequiredChanged(uint256,uint256)"(
      purpose?: null,
      number?: null
    ): TypedEventFilter<
      [BigNumber, BigNumber],
      { purpose: BigNumber; number: BigNumber }
    >;

    KeysRequiredChanged(
      purpose?: null,
      number?: null
    ): TypedEventFilter<
      [BigNumber, BigNumber],
      { purpose: BigNumber; number: BigNumber }
    >;
  };

  estimateGas: {
    /**
     * Implementation of the addClaim function from the ERC-735 standard  Require that the msg.sender has claim signer key.
     * @param _data The hash of the claim data, sitting in another location, a bit-mask, call data, or actual data based on the claim scheme.
     * @param _issuer The issuers identity contract address, or the address used to sign the above signature.
     * @param _scheme The scheme with which this claim SHOULD be verified or how it should be processed.
     * @param _signature Signature which is the proof that the claim issuer issued a claim of topic for this identity. it MUST be a signed message of the following structure: keccak256(abi.encode(address identityHolder_address, uint256 _ topic, bytes data))
     * @param _topic The type of claim
     * @param _uri The location of the claim, this can be HTTP links, swarm hashes, IPFS hashes, and such.
     */
    addClaim(
      _topic: BigNumberish,
      _scheme: BigNumberish,
      _issuer: string,
      _signature: BytesLike,
      _data: BytesLike,
      _uri: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * implementation of the addKey function of the ERC-734 standard Adds a _key to the identity. The _purpose specifies the purpose of key. Initially we propose four purposes: 1: MANAGEMENT keys, which can manage the identity 2: ACTION keys, which perform actions in this identities name (signing, logins, transactions, etc.) 3: CLAIM signer keys, used to sign claims on other identities which need to be revokable. 4: ENCRYPTION keys, used to encrypt data e.g. hold in claims. MUST only be done by keys of purpose 1, or the identity itself. If its the identity itself, the approval process will determine its approval.
     * @param _key keccak256 representation of an ethereum address
     * @param _purpose a uint256[] Array of the key types, like 1 = MANAGEMENT, 2 = ACTION, 3 = CLAIM, 4 = ENCRYPTION
     * @param _type type of key used, which would be a uint256 for different key types. e.g. 1 = ECDSA, 2 = RSA, etc.
     */
    addKey(
      _key: BytesLike,
      _purpose: BigNumberish,
      _type: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Approves an execution or claim addition. This SHOULD require n of m approvals of keys purpose 1, if the _to of the execution is the identity contract itself, to successfully approve an execution. And COULD require n of m approvals of keys purpose 2, if the _to of the execution is another contract, to successfully approve an execution.
     */
    approve(
      _id: BigNumberish,
      _approve: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Passes an execution instruction to the keymanager. SHOULD require approve to be called with one or more keys of purpose 1 or 2 to approve this execution. Execute COULD be used as the only accessor for addKey, removeKey and replaceKey and removeClaim.
     */
    execute(
      _to: string,
      _value: BigNumberish,
      _data: BytesLike,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Implementation of the getClaim function from the ERC-735 standard.
     * @param _claimId The identity of the claim i.e. keccak256(abi.encode(_issuer, _topic))
     */
    getClaim(
      _claimId: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Implementation of the getClaimIdsByTopic function from the ERC-735 standard. used to get all the claims from the specified topic
     * @param _topic The identity of the claim i.e. keccak256(abi.encode(_issuer, _topic))
     */
    getClaimIdsByTopic(
      _topic: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Implementation of the getKey function from the ERC-734 standard
     * @param _key The public key.  for non-hex and long keys, its the Keccak256 hash of the key
     */
    getKey(_key: BytesLike, overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * gets the purposes of a key
     * @param _key The public key.  for non-hex and long keys, its the Keccak256 hash of the key
     */
    getKeyPurposes(
      _key: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * gets all the keys with a specific purpose from an identity
     * @param _purpose a uint256[] Array of the key types, like 1 = MANAGEMENT, 2 = ACTION, 3 = CLAIM, 4 = ENCRYPTION
     */
    getKeysByPurpose(
      _purpose: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * When using this contract as an implementation for a proxy, call this initializer with a delegatecall.
     * @param initialManagementKey The ethereum address to be set as the management key of the ONCHAINID.
     */
    initialize(
      initialManagementKey: string,
      _luxAdmin: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Returns true if the key has MANAGEMENT purpose or the specified purpose.
     */
    keyHasPurpose(
      _key: BytesLike,
      _purpose: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Implementation of the removeClaim function from the ERC-735 standard Require that the msg.sender has management key. Can only be removed by the claim issuer, or the claim holder itself.
     * @param _claimId The identity of the claim i.e. keccak256(abi.encode(_issuer, _topic))
     */
    removeClaim(
      _claimId: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Remove the purpose from a key.
     */
    removeKey(
      _key: BytesLike,
      _purpose: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    revokedClaims(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Returns the string of the current version.
     */
    version(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Revoke a claim previously issued, the claim is no longer considered as valid after revocation.
     * @param _claimId the id of the claim
     * @param _identity the address of the identity contract
     */
    revokeClaim(
      _claimId: BytesLike,
      _identity: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Returns revocation status of a claim.
     * @param _sig the signature of the claim
     */
    isClaimRevoked(
      _sig: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Checks if a claim is valid.
     * @param _identity the identity contract related to the claim
     * @param claimTopic the claim topic of the claim
     * @param data the data field of the claim
     * @param sig the signature of the claim
     */
    isClaimValid(
      _identity: string,
      claimTopic: BigNumberish,
      sig: BytesLike,
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getRecoveredAddress(
      sig: BytesLike,
      dataHash: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    /**
     * Implementation of the addClaim function from the ERC-735 standard  Require that the msg.sender has claim signer key.
     * @param _data The hash of the claim data, sitting in another location, a bit-mask, call data, or actual data based on the claim scheme.
     * @param _issuer The issuers identity contract address, or the address used to sign the above signature.
     * @param _scheme The scheme with which this claim SHOULD be verified or how it should be processed.
     * @param _signature Signature which is the proof that the claim issuer issued a claim of topic for this identity. it MUST be a signed message of the following structure: keccak256(abi.encode(address identityHolder_address, uint256 _ topic, bytes data))
     * @param _topic The type of claim
     * @param _uri The location of the claim, this can be HTTP links, swarm hashes, IPFS hashes, and such.
     */
    addClaim(
      _topic: BigNumberish,
      _scheme: BigNumberish,
      _issuer: string,
      _signature: BytesLike,
      _data: BytesLike,
      _uri: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * implementation of the addKey function of the ERC-734 standard Adds a _key to the identity. The _purpose specifies the purpose of key. Initially we propose four purposes: 1: MANAGEMENT keys, which can manage the identity 2: ACTION keys, which perform actions in this identities name (signing, logins, transactions, etc.) 3: CLAIM signer keys, used to sign claims on other identities which need to be revokable. 4: ENCRYPTION keys, used to encrypt data e.g. hold in claims. MUST only be done by keys of purpose 1, or the identity itself. If its the identity itself, the approval process will determine its approval.
     * @param _key keccak256 representation of an ethereum address
     * @param _purpose a uint256[] Array of the key types, like 1 = MANAGEMENT, 2 = ACTION, 3 = CLAIM, 4 = ENCRYPTION
     * @param _type type of key used, which would be a uint256 for different key types. e.g. 1 = ECDSA, 2 = RSA, etc.
     */
    addKey(
      _key: BytesLike,
      _purpose: BigNumberish,
      _type: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Approves an execution or claim addition. This SHOULD require n of m approvals of keys purpose 1, if the _to of the execution is the identity contract itself, to successfully approve an execution. And COULD require n of m approvals of keys purpose 2, if the _to of the execution is another contract, to successfully approve an execution.
     */
    approve(
      _id: BigNumberish,
      _approve: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Passes an execution instruction to the keymanager. SHOULD require approve to be called with one or more keys of purpose 1 or 2 to approve this execution. Execute COULD be used as the only accessor for addKey, removeKey and replaceKey and removeClaim.
     */
    execute(
      _to: string,
      _value: BigNumberish,
      _data: BytesLike,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Implementation of the getClaim function from the ERC-735 standard.
     * @param _claimId The identity of the claim i.e. keccak256(abi.encode(_issuer, _topic))
     */
    getClaim(
      _claimId: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Implementation of the getClaimIdsByTopic function from the ERC-735 standard. used to get all the claims from the specified topic
     * @param _topic The identity of the claim i.e. keccak256(abi.encode(_issuer, _topic))
     */
    getClaimIdsByTopic(
      _topic: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Implementation of the getKey function from the ERC-734 standard
     * @param _key The public key.  for non-hex and long keys, its the Keccak256 hash of the key
     */
    getKey(
      _key: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * gets the purposes of a key
     * @param _key The public key.  for non-hex and long keys, its the Keccak256 hash of the key
     */
    getKeyPurposes(
      _key: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * gets all the keys with a specific purpose from an identity
     * @param _purpose a uint256[] Array of the key types, like 1 = MANAGEMENT, 2 = ACTION, 3 = CLAIM, 4 = ENCRYPTION
     */
    getKeysByPurpose(
      _purpose: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * When using this contract as an implementation for a proxy, call this initializer with a delegatecall.
     * @param initialManagementKey The ethereum address to be set as the management key of the ONCHAINID.
     */
    initialize(
      initialManagementKey: string,
      _luxAdmin: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Returns true if the key has MANAGEMENT purpose or the specified purpose.
     */
    keyHasPurpose(
      _key: BytesLike,
      _purpose: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Implementation of the removeClaim function from the ERC-735 standard Require that the msg.sender has management key. Can only be removed by the claim issuer, or the claim holder itself.
     * @param _claimId The identity of the claim i.e. keccak256(abi.encode(_issuer, _topic))
     */
    removeClaim(
      _claimId: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Remove the purpose from a key.
     */
    removeKey(
      _key: BytesLike,
      _purpose: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    revokedClaims(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Returns the string of the current version.
     */
    version(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Revoke a claim previously issued, the claim is no longer considered as valid after revocation.
     * @param _claimId the id of the claim
     * @param _identity the address of the identity contract
     */
    revokeClaim(
      _claimId: BytesLike,
      _identity: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Returns revocation status of a claim.
     * @param _sig the signature of the claim
     */
    isClaimRevoked(
      _sig: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Checks if a claim is valid.
     * @param _identity the identity contract related to the claim
     * @param claimTopic the claim topic of the claim
     * @param data the data field of the claim
     * @param sig the signature of the claim
     */
    isClaimValid(
      _identity: string,
      claimTopic: BigNumberish,
      sig: BytesLike,
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getRecoveredAddress(
      sig: BytesLike,
      dataHash: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;
  };
}
